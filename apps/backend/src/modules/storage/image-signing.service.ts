import { Injectable, Logger } from '@nestjs/common'
import { ConfigService } from '@nestjs/config'
import * as crypto from 'crypto'

/**
 * Generates time-limited signed URLs for secure image access.
 * Algorithm: HMAC-SHA256, Payload: imageId:variant:expires
 */
@Injectable()
export class ImageSigningService {
  private readonly logger = new Logger(ImageSigningService.name)
  private readonly signingKey: Buffer | null = null
  private readonly expiresIn: number
  private readonly enabled: boolean
  private readonly baseUrl: string

  constructor(private configService: ConfigService) {
    const keyHex = this.configService.get<string>('IMAGE_SIGNING_KEY')
    this.baseUrl = this.configService.get<string>('BASE_URL', 'http://localhost:11104')

    if (keyHex && keyHex.length === 64) {
      this.signingKey = Buffer.from(keyHex, 'hex')
      this.logger.log('Image signing key loaded successfully')
    } else if (keyHex) {
      this.logger.warn(
        'IMAGE_SIGNING_KEY must be a 64-character hex string (32 bytes). Signing disabled.',
      )
    }

    this.expiresIn = parseInt(
      this.configService.get<string>('IMAGE_SIGNED_URL_EXPIRES', '90'),
      10,
    )

    this.enabled =
      this.signingKey !== null &&
      this.configService.get<string>('IMAGE_SIGNED_URL_ENABLED', 'false') ===
        'true'

    if (this.enabled) {
      this.logger.log(
        `Image signing enabled with ${this.expiresIn}s expiration`,
      )
    }
  }

  /**
   * Check if signed URL verification is enabled
   */
  isEnabled(): boolean {
    return this.enabled
  }

  /**
   * Generate a signed URL for an image
   *
   * @deprecated Use {@link generateSignedUrlV2} instead. This method uses v1 payload format
   * (`imageId:boolean:expires`) which is incompatible with the current verification logic
   * that expects v2 format (`imageId:variant:expires`).
   *
   * @param imageId - The image ID
   * @param thumbnail - Whether this is for a thumbnail
   * @returns Signed URL and expiration timestamp
   */
  generateSignedUrl(
    imageId: string,
    thumbnail: boolean = false,
  ): {
    url: string
    expiresAt: number
  } {
    if (!this.signingKey) {
      throw new Error('Image signing key not configured')
    }

    const expires = Math.floor(Date.now() / 1000) + this.expiresIn
    const payload = this.createPayload(imageId, thumbnail, expires)
    const token = this.sign(payload)

    const thumbParam = thumbnail ? '&thumb=true' : ''
    const baseApiUrl = this.baseUrl.replace(/\/$/, '')
    return {
      url: `${baseApiUrl}/api/images/${imageId}?token=${token}&expires=${expires}${thumbParam}`,
      expiresAt: expires,
    }
  }

  /**
   * Verify a signed URL token
   *
   * @deprecated Use {@link verifyTokenV2} instead. This method uses v1 payload format
   * (`imageId:boolean:expires`) which is incompatible with tokens generated by
   * {@link generateSignedUrlV2}.
   *
   * @param imageId - The image ID from the URL
   * @param thumbnail - Whether this is a thumbnail request
   * @param token - The signature token from the URL
   * @param expires - The expiration timestamp from the URL
   * @returns true if the token is valid and not expired
   */
  verifyToken(
    imageId: string,
    thumbnail: boolean,
    token: string,
    expires: string,
  ): boolean {
    if (!this.signingKey) {
      return false
    }

    const now = Math.floor(Date.now() / 1000)
    const expiresNum = parseInt(expires, 10)

    if (isNaN(expiresNum) || expiresNum < now) {
      return false
    }

    const payload = this.createPayload(imageId, thumbnail, expiresNum)
    const expectedToken = this.sign(payload)

    // Use timing-safe comparison to prevent timing attacks
    try {
      const tokenBuffer = Buffer.from(token)
      const expectedBuffer = Buffer.from(expectedToken)

      // Buffers must be the same length for timingSafeEqual
      if (tokenBuffer.length !== expectedBuffer.length) {
        return false
      }

      return crypto.timingSafeEqual(tokenBuffer, expectedBuffer)
    } catch {
      return false
    }
  }

  /**
   * Generate a signed URL for an image (v2 - supports original variant)
   *
   * @param imageId - The image ID
   * @param variant - Image variant: 'thumbnail', 'standard', or 'original'
   * @returns Signed URL and expiration timestamp
   */
  generateSignedUrlV2(
    imageId: string,
    variant: 'thumbnail' | 'standard' | 'original' = 'standard',
  ): {
    url: string
    expiresAt: number
  } {
    if (!this.signingKey) {
      throw new Error('Image signing key not configured')
    }

    const expires = Math.floor(Date.now() / 1000) + this.expiresIn
    const payload = this.createPayloadV2(imageId, variant, expires)
    const token = this.sign(payload)

    let queryParams = `token=${token}&expires=${expires}`
    if (variant === 'thumbnail') {
      queryParams += '&thumb=true'
    } else if (variant === 'original') {
      queryParams += '&original=true'
    }

    const baseApiUrl = this.baseUrl.replace(/\/$/, '')
    return {
      url: `${baseApiUrl}/api/images/${imageId}?${queryParams}`,
      expiresAt: expires,
    }
  }

  /**
   * Verify a signed URL token (v2 - supports original variant)
   *
   * @param imageId - The image ID from the URL
   * @param variant - Image variant: 'thumbnail', 'standard', or 'original'
   * @param token - The signature token from the URL
   * @param expires - The expiration timestamp from the URL
   * @returns true if the token is valid and not expired
   */
  verifyTokenV2(
    imageId: string,
    variant: 'thumbnail' | 'standard' | 'original',
    token: string,
    expires: string,
  ): boolean {
    if (!this.signingKey) {
      return false
    }

    const now = Math.floor(Date.now() / 1000)
    const expiresNum = parseInt(expires, 10)

    if (isNaN(expiresNum) || expiresNum < now) {
      return false
    }

    const payload = this.createPayloadV2(imageId, variant, expiresNum)
    const expectedToken = this.sign(payload)

    // Use timing-safe comparison to prevent timing attacks
    try {
      const tokenBuffer = Buffer.from(token)
      const expectedBuffer = Buffer.from(expectedToken)

      // Buffers must be the same length for timingSafeEqual
      if (tokenBuffer.length !== expectedBuffer.length) {
        return false
      }

      return crypto.timingSafeEqual(tokenBuffer, expectedBuffer)
    } catch {
      return false
    }
  }

  /**
   * Create the payload string for signing
   */
  private createPayload(
    imageId: string,
    thumbnail: boolean,
    expires: number,
  ): string {
    return `${imageId}:${thumbnail}:${expires}`
  }

  /**
   * Create the payload string for signing (v2)
   */
  private createPayloadV2(
    imageId: string,
    variant: 'thumbnail' | 'standard' | 'original',
    expires: number,
  ): string {
    return `${imageId}:${variant}:${expires}`
  }

  /**
   * Sign a payload using HMAC-SHA256
   */
  private sign(payload: string): string {
    return crypto
      .createHmac('sha256', this.signingKey!)
      .update(payload)
      .digest('base64url')
  }
}
